#include "IMU.h"
#include "IfxI2c_PinMap.h"
#include "Time.h"
#include <math.h>

#define MPU6050_ADDR 0xD0

#define MPU6050_PI (3.141592653589793238462)

#define MPU6050_ACCEL_XOUT_H        (0x3B)
#define MPU6050_GYRO_XOUT_H         (0x43)

double _imu_accel[3], _imu_omega[3], _imu_theta[3];
double _thetaZ_offset;

unsigned char _dmpdatas[42]; //DMP数据

EI2C_Typedef _MPU6050_I2C_Struct;

uint8 _dmpmemorydata[1929]={
// bank 0, 256 bytes
   0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
   0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
   0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
   0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
   0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
   0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
   0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
   0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
   0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
   0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
   0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
   // bank 1, 256 bytes
   0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
   0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
   0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
   0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
   0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
   // bank 2, 256 bytes
   0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
   0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   // bank 3, 256 bytes
   0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
   0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
   0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
   0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
   0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
   0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
   0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
   0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
   0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
   0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
   0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
   0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
   0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
   0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
   0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
   0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
   // bank 4, 256 bytes
   0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
   0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
   0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
   0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
   0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
   0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
   0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
   0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
   0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
   0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
   0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
   0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
   0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
   0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
   0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
   0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
   // bank 5, 256 bytes
   0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
   0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
   0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
   0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
   0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
   0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
   0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
   0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
   0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
   0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
   0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
   0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
   0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
   0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
   0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
   0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
   // bank 6, 256 bytes
   0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
   0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
   0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
   0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
   0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
   0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
   0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
   0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
   0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
   0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
   0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
   0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
   0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
   0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
   0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
   0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
   // bank 7, 138 bytes (remainder)
   0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
   0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
   0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
   0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
   0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
   0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
   0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
   0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
   0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

uint8 _dmpcfgupddata[192] = {
//  dmp config
//  BANK    OFFSET  LENGTH  [DATA]
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,
    0x00,   0x6C,   0x02,   0x20, 0x00,
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,
    0x00,   0xA3,   0x01,   0x00,
    0x00,   0x00,   0x00,   0x01,   //这里是开启DMP的特殊中断的
    //原程序中此行代码为(这里不一定错)
    //0x00,   0x00,   0x00,   0x01,  即LENGTH=0x00，有错

    0x07,   0x86,   0x01,   0xFE,
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,
    0x07,   0x7E,   0x01,   0x30,
    0x07,   0x46,   0x01,   0x9A,
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,
    0x02,   0x16,   0x02,   0x00, 0x01,
/* 上行最后一个数据调整FIFO rate :0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,
// 可从 datasheet 公式推算
//dmp updates
    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00*/
};

uint8 _dmpUpdates[47]={

    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00

};

EI2C_Status _MPU6050_Write_Byte(uint8 reg, uint8 data) {
    return EI2C_Mem_Write(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, &data, 1);
}

EI2C_Status _MPU6050_Write_Bytes(uint8 reg, uint8 length, uint8* p_data) {
    return EI2C_Mem_Write(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, p_data, length);
}

EI2C_Status _MPU6050_Write_Bit(uint8 reg, uint8 bitNum, uint8 data) {
    uint8 currentData;
    EI2C_Status status;
    status = EI2C_Mem_Read(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    if (status != EI2C_OK) {
        return status;
    }
    if (data) {
        currentData |= (1 << bitNum);
    } else {
        currentData &= ~(1 << bitNum);
    }
    return EI2C_Mem_Write(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
}

EI2C_Status _MPU6050_Write_Bits(uint8 reg, uint8 bitStart, uint8 length, uint8 data) {
    uint8 currentData = 0;
    EI2C_Status status;
    status = EI2C_Mem_Read(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    if (status != EI2C_OK) {
        return status;
    }
    uint8 mask = ((1 << length) - 1) << (bitStart - length + 1);
    currentData &= ~mask; // Clear the bits
    currentData |= (data << (bitStart - length + 1)) & mask; // Set the bits
    return EI2C_Mem_Write(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
}

EI2C_Status _MPU6050_Read_Byte(uint8 reg, uint8 *data) {
    return EI2C_Mem_Read(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, data, 1);
}

EI2C_Status _MPU6050_Read_Bytes(uint8 reg, uint16 length, uint8 *data) {
    return EI2C_Mem_Read(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, data, length);
}

EI2C_Status _MPU6050_Read_Bit(uint8 reg, uint8 bitNum, uint8 *data) {
    uint8 currentData;
    EI2C_Status status;
    status = EI2C_Mem_Read(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    *data = currentData & (1 << bitNum);
    return status;
}

EI2C_Status _MPU6050_Read_Bits(uint8 reg, uint8 bitStart, uint8 length, uint8 *data) {
    uint8 currentData = 0;
    EI2C_Status status;
    status = EI2C_Mem_Read(&_MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    uint8 mask = ((1 << length) - 1) << (bitStart - length + 1);
    currentData &= mask;
    currentData >>= (bitStart - length + 1);
    *data = currentData;
    return status;
}


/*
   加载 DMP代码固件
   返回值  (1=成功,0=失败)
 */
unsigned char _loadfirmware(void)
{
  unsigned int datanum=0;   //DMP固件写入标志位
  unsigned char ye,i;
  unsigned char bank=0; //段（256个数据一段）
  unsigned char addr=0;

    for(;bank<8;bank++)
    {
        if(bank == 7)   //这里的作用就是区分最后一段数据
            i = 8;
        else
            i = 16;
        for(ye=0;ye<i;ye++)
        {
            _MPU6050_Write_Byte(0x6d,bank);
            _MPU6050_Write_Byte(0x6e,addr);

            _MPU6050_Write_Bytes(0x6f,16,&_dmpmemorydata[datanum]);
            datanum += 16;
            addr += 16;
        }
    }
    _MPU6050_Write_Byte(0x6d,7);
    _MPU6050_Write_Byte(0x6e,addr);

    _MPU6050_Write_Bytes(0x6f,9,&_dmpmemorydata[datanum]);
    datanum += 9;

    return 1;
}

unsigned char _loadcfgupd(void)  //DMP设置
{
  unsigned char line;   //一共需要写入30条设置数据
  unsigned char bank;   //页
  unsigned char datacounts=0;   //DMP设置数据标志位
  unsigned char bytes2write;    //数据长度。
  unsigned char offset; //偏移地址
  unsigned char special;

  for (line=0;line<30;line++)
  {
    bank=_dmpcfgupddata[datacounts++];
    offset=_dmpcfgupddata[datacounts++];
    bytes2write=_dmpcfgupddata[datacounts++];
    _MPU6050_Write_Byte(0x6d,bank);
    _MPU6050_Write_Byte(0x6e,offset);

    _MPU6050_Write_Bytes(0x6f,bytes2write,&_dmpcfgupddata[datacounts]);
    datacounts += bytes2write;

    if(0 == bytes2write) {
        special=_dmpcfgupddata[datacounts++];
        if(0x01 == special){
            //设置零运动中断启用（真）;
            //设置FIFO缓冲区溢出启用（真）;
            //设置DMP启用（真）;
            _MPU6050_Write_Byte(0x38,0x32);
        }
        else
            return 0;
    }
  }
    return 1;
}

/*最后更新DMP*/
unsigned char _xdmpUpdates(unsigned char datacounts)
{
    unsigned char bank,offset,bytes2write;
    bank=_dmpUpdates[datacounts++];
    offset=_dmpUpdates[datacounts++];
    bytes2write=_dmpUpdates[datacounts++];
    _MPU6050_Write_Byte(0x6d,bank);
    _MPU6050_Write_Byte(0x6e,offset);

    _MPU6050_Write_Bytes(0x6f,bytes2write,&_dmpUpdates[datacounts]);

    return 1;
}

/*读取 FIFO 计数*/
unsigned int _getFIFOCount()
{
    unsigned char i[2];
    _MPU6050_Read_Bytes(0x72,2,i);
    return ((i[0]<<8)+i[1]);
}

/*FIFO数据读取
参数 *Data    存储数据的地址
返回值 (1=读取成功,0读取失败)
*/
EI2C_Status _readdmp(unsigned char *Data)
{
  return _MPU6050_Read_Bytes(0x74,42,Data);
}

//加载并配置 DMP 数字运动处理引擎
unsigned char _dmpInitialize(void)
{
    unsigned char hwRevision,otpValid,mpuIntStatus/*fifoBuffer[128]*/;
    unsigned char xgOffsetTC,ygOffsetTC,zgOffsetTC;
    unsigned int fifoCount;
    _MPU6050_Write_Bit(0x6B,7,1); //复位 MPU6050
    Time_Delay_us(30000);
    _MPU6050_Write_Bit(0x6B,6,0); //禁止睡眠模式
    _MPU6050_Write_Byte(0x6D,0x70);    //写入一个字节数据到0x6d寄存器(选择用户 bank)
    _MPU6050_Write_Byte(0x6E,0x06);    //写入一个字节数据到0x6e寄存器(选择存储字节)
    _MPU6050_Read_Byte(0x6F,&hwRevision);  //读取
    _MPU6050_Write_Byte(0x6D,0);   //重置内存 bank 选择
    _MPU6050_Read_Bit(0x00,0,&otpValid);  //读取 OTP bank 有效标志
    _MPU6050_Read_Bits(0x00,6,6,&xgOffsetTC); //读陀螺偏置TC值 X
    _MPU6050_Read_Bits(0x01,6,6,&ygOffsetTC); //读陀螺偏置TC值 Y)
    _MPU6050_Read_Bits(0x02,6,6,&zgOffsetTC); //读陀螺偏置TC值 Z
    _MPU6050_Write_Byte(0x25,0x7f);    //设置从0地址 0x7
    _MPU6050_Write_Bit(0x6A,5,0); //禁用I2C主模式
    _MPU6050_Write_Byte(0x25,0x68);    //这里可能要改。还没有弄明白这里
    _MPU6050_Write_Bit(0x6A,1,1); //I2C总线主控复位
    Time_Delay_us(20000);
    if((_loadfirmware()) == 0 ) return 0;    //加载 DMP代码到内存
    if((_loadcfgupd()) == 0 ) return 0;  //配制DMP
    _MPU6050_Write_Bits(0x6B,2,3,0x03);   //设置时钟脉冲源Z陀螺
    _MPU6050_Write_Byte(0x38,0x12);    //设置DMP和FIFO_OFLOW启用中断
    _MPU6050_Write_Byte(0x19,4);   //设置采样率为200 hz  (1khz / (1 + 4) = 200 Hz)
    _MPU6050_Write_Bits(0x1A,5,3,0x1);    //设置外部帧同步TEMP_OUT_L[0]
    _MPU6050_Write_Bits(0x1A,2,3,0x03);   //设置DLPF带宽42赫兹
    _MPU6050_Write_Bits(0x1B,4,2,0x03);   //陀螺灵敏度设置为+ / - 2000 deg/sec，量程初始化在下面的init函数里做了
    _MPU6050_Write_Byte(0x70,0x03);    //设置DMP配置字节（功能未知）
    _MPU6050_Write_Byte(0x71,0x00);    //设置DMP配置字节（功能未知）
    _MPU6050_Write_Bit(0x00,0,0); //清除OTP Bank 标志
    _MPU6050_Write_Bits(0x00,6,6,xgOffsetTC); //设置X 陀螺抵消TCs之前的值
    _MPU6050_Write_Bits(0x01,6,6,ygOffsetTC); //设置Y 陀螺抵消TCs之前的值
    _MPU6050_Write_Bits(0x02,6,6,zgOffsetTC); //设置Z 陀螺抵消TCs之前的值
    _xdmpUpdates(0); //最后更新1/7(函数未知)dmpUpdates数组第一行
    _xdmpUpdates(5); //最后更新2/7(函数未知)dmpUpdates数组第二行
    _MPU6050_Write_Bit(0x6A,2,1); //复位 FIFO
    fifoCount = _getFIFOCount(); //读取 FIFO 计数
    //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
    _MPU6050_Write_Bit(0x6A,2,1); //复位 FIFO

    _MPU6050_Write_Byte(0x1F,2);   //运动检测阈值设置为2
    _MPU6050_Write_Byte(0x21,156); //零运动检测阈值为156
    _MPU6050_Write_Byte(0x20,80);  //设置运动检测持续时间至80
    _MPU6050_Write_Byte(0x22,0);   //设置零运动检测时间0
    _MPU6050_Write_Bit(0x6A,2,1); //复位 FIFO
    _MPU6050_Write_Bit(0x6A,6,1); //使能 FIFO
    _MPU6050_Write_Bit(0x6A,7,1); //使能 DMP
    _MPU6050_Write_Bit(0x6A,3,1); //复位 DMP
    _xdmpUpdates(12);    //最后更新3/7(函数未知)dmpUpdates数组第三行
    _xdmpUpdates(17);    //最后更新4/7(函数未知)dmpUpdates数组第四行
    _xdmpUpdates(28);    //最后更新5/7(函数未知)dmpUpdates数组第五行
    while((fifoCount = _getFIFOCount()) < 3);    //等待 FIFO 计数 > 2
    _MPU6050_Write_Bit(0x6A,2,1); //复位 FIFO
    //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
    _MPU6050_Read_Byte(0x3A,&mpuIntStatus);    //读取中断状态
    _xdmpUpdates(35);    //最后更新6/7(函数未知)dmpUpdates数组第六行
    while((fifoCount = _getFIFOCount()) < 3);    //等待 FIFO 计数 > 2
    _MPU6050_Write_Bit(0x6A,2,1); //复位 FIFO
    //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
    _MPU6050_Read_Byte(0x3A,&mpuIntStatus);    //读取中断状态
    _xdmpUpdates(40);    //最后更新7/7(函数未知)dmpUpdates数组第七行
    _MPU6050_Write_Bit(0x6A,7,0); //禁用DMP(稍后您打开它)
    _MPU6050_Write_Bit(0x6A,2,1); //复位 FIFO
    _MPU6050_Read_Byte(0x3A,&mpuIntStatus);
    //星期六 (2014/06/28)
    return 1;
}

/*初始化MPU6050*/
void MPU6050_Init(void)
{
    _MPU6050_I2C_Struct.scl_port = I2C_SCL_I2C_PIN.pin.port;
    _MPU6050_I2C_Struct.scl_pin = I2C_SCL_I2C_PIN.pin.pinIndex;

    _MPU6050_I2C_Struct.sda_port = I2C_SDA_I2C_PIN.pin.port;
    _MPU6050_I2C_Struct.sda_pin = I2C_SDA_I2C_PIN.pin.pinIndex;

    _MPU6050_I2C_Struct.status = EI2C_NOT_READY;

    _MPU6050_Write_Bits (0x6B,2,3,0x01);  //电源管理
    //writeBits (0x1B,4,2,0x00);    //设置陀螺仪量程 250/s
    _MPU6050_Write_Bits (0x1C,4,2,0x00);  //设置加速度量程 2G
    _MPU6050_Write_Bit (0x6B,6,1);    //电源管理MUP进入睡眠模式

    _dmpInitialize();

    _MPU6050_Write_Bit(0x6A,7,1);   //使能DMP

    Time_Delay_us(2e5);

    MPU6050_ThetaZ_Reset();
}

/*验证MPU6050连接*/
unsigned char getDeviceID(void)
{
    unsigned char b=0;  //临时变量
    _MPU6050_Read_Bits(0x75,6,6,&b);  //读取i2c固定地址，去掉最高位和最低位这两位数据，因此默认为0x68(0x34左移一位)
    return b == 0x34;   //判断B是否等于0x34，如果等于返回1，不等于返回0
}

EI2C_Status MPU6050_Update_Accel() {
    uint8 dat[6];

    EI2C_Status ret = _MPU6050_Read_Bytes(MPU6050_ACCEL_XOUT_H, 6, dat);
    _imu_accel[0] = ((sint16)(((uint16)dat[0] << 8 | dat[1]))) * 9.81 / 16384.0;
    _imu_accel[1] = ((sint16)(((uint16)dat[2] << 8 | dat[3]))) * 9.81 / 16384.0;
    _imu_accel[2] = ((sint16)(((uint16)dat[4] << 8 | dat[5]))) * 9.81 / 16384.0;

    return ret;
}

EI2C_Status MPU6050_Update_Omega(void) {
    uint8 dat[6];

    EI2C_Status ret = _MPU6050_Read_Bytes(MPU6050_GYRO_XOUT_H, 6, dat);
    _imu_omega[0] = ((sint16)(((uint16)dat[0] << 8 | dat[1]))) / 32.8;
    _imu_omega[1] = ((sint16)(((uint16)dat[2] << 8 | dat[3]))) / 32.8;
    _imu_omega[2] = ((sint16)(((uint16)dat[4] << 8 | dat[5]))) / 32.8;

    return ret;
}

double _yaw_last = 0;
sint8 _ang_state = 0;

double _angle_with_round(double *ang_last,double *ang_now,sint8 *ang_state)//用于连续追踪角度变化，防止在函数边界的相位跳变
{
    if(*ang_last>145.0 && *ang_now<-145.0) *ang_state=*ang_state+1;
    if(*ang_last<-145.0 && *ang_now>145.0) *ang_state=*ang_state-1;
    return ((*ang_now)+(*ang_state)*360.0);
}

EI2C_Status MPU6050_Update_Theta(void) {
    unsigned int mpu6050_fifo_count = 0;
    uint8 zd;
    _MPU6050_Read_Byte(0x3A,&zd);
    _MPU6050_Write_Bit(0x6A,7,0);   //禁用DMP
    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO
    _MPU6050_Write_Bit(0x6A,7,1);   //使能DMP

    while(mpu6050_fifo_count<42)
    {
        mpu6050_fifo_count=_getFIFOCount();//(&MPU6050);
    }
    EI2C_Status ret = _readdmp(_dmpdatas);    //读取FIFO数据(四元数)

    double Q[4];//四元数
    Q[0] = (double)(sint16)((_dmpdatas[0] << 8 | _dmpdatas[1]))/16384;
    Q[1] = (double)(sint16)((_dmpdatas[4] << 8 | _dmpdatas[5]))/16384;
    Q[2] = (double)(sint16)((_dmpdatas[8] << 8 | _dmpdatas[9]))/16384;
    Q[3] = (double)(sint16)((_dmpdatas[12] << 8 | _dmpdatas[13]))/16384;

    double pitch = asin(-2 * Q[1] * Q[3] + 2 * Q[0]* Q[2]) / MPU6050_PI * 180.0;    // pitch
    double roll  = atan2((2 * Q[2] * Q[3] + 2 * Q[0] * Q[1]),(-2 * Q[1] * Q[1] - 2 * Q[2]* Q[2] + 1)) / MPU6050_PI * 180.0; // roll
    //获取偏航角
    double yaw_temp=atan2(2 * (Q[1] * Q[2] + Q[0] * Q[3]),(1-2*Q[2]*Q[2]-2*Q[3]*Q[3])) / MPU6050_PI * 180.0;  //yaw
    double yaw=_angle_with_round(&_yaw_last,&yaw_temp,&_ang_state);
    _yaw_last=yaw_temp;//保持比较的两个角都在-180~180之间

    _imu_theta[0] = pitch;
    _imu_theta[1] = roll;
    _imu_theta[2] = yaw;

    return ret;
}

void MPU6050_Get_Accel(double *accelX, double *accelY, double *accelZ){
    *accelX = _imu_accel[0];
    *accelY = _imu_accel[1];
    *accelZ = _imu_accel[2];
}

void MPU6050_Get_Omega(double *omegaX, double *omegaY, double *omegaZ){
    *omegaX = _imu_omega[0];
    *omegaY = _imu_omega[1];
    *omegaZ = _imu_omega[2];
}

void MPU6050_Get_Theta(double *thetaX, double *thetaY, double *thetaZ){
    *thetaX = _imu_theta[0];
    *thetaY = _imu_theta[1];
    *thetaZ = _imu_theta[2];
}


double MPU6050_Get_AccelX(void){
    return _imu_accel[0];
}

double MPU6050_Get_AccelY(void){
    return _imu_accel[1];
}

double MPU6050_Get_AccelZ(void){
    return _imu_accel[2];
}

double MPU6050_Get_OmegaX(void){
    return _imu_omega[0];
}

double MPU6050_Get_OmegaY(void) {
    return _imu_omega[1];
}

double MPU6050_Get_OmegaZ(void) {
    return _imu_omega[2];
}

double MPU6050_Get_ThetaX(void) {
    return _imu_theta[0];
}

double MPU6050_Get_ThetaY(void) {
    return _imu_theta[1];
}

double MPU6050_Get_ThetaZ(void) {
    return _imu_theta[2] - _thetaZ_offset;
}

void MPU6050_ThetaZ_Reset(void) {
    MPU6050_Update_Theta();
    _thetaZ_offset += MPU6050_Get_ThetaZ();
}
