#include "Display.h"
#include "EI2C.h"
#include "IfxI2c_PinMap.h"
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <stdarg.h>

#define OLED_I2C_ADDRESS        0x78	//I2C地址

/*中文字符字节宽度*/
#define OLED_CHN_CHAR_WIDTH         3       //UTF-8编码格式给3，GB2312编码格式给2

/*字模基本单元*/
typedef struct
{
    uint8 Data[32];                     //字模数据
    char Index[OLED_CHN_CHAR_WIDTH + 1];    //汉字索引
} ChineseCell_t;

EI2C_Typedef OLED_I2C_Struct;   //I2C结构体

/**
  * 数据存储格式：
  * 纵向8点，高位在下，先从左到右，再从上到下
  * 每一个Bit对应一个像素点
  * 
  *      B0 B0                  B0 B0
  *      B1 B1                  B1 B1
  *      B2 B2                  B2 B2
  *      B3 B3  ------------->  B3 B3 --
  *      B4 B4                  B4 B4  |
  *      B5 B5                  B5 B5  |
  *      B6 B6                  B6 B6  |
  *      B7 B7                  B7 B7  |
  *                                    |
  *  -----------------------------------
  *  |   
  *  |   B0 B0                  B0 B0
  *  |   B1 B1                  B1 B1
  *  |   B2 B2                  B2 B2
  *  --> B3 B3  ------------->  B3 B3
  *      B4 B4                  B4 B4
  *      B5 B5                  B5 B5
  *      B6 B6                  B6 B6
  *      B7 B7                  B7 B7
  * 
  * 坐标轴定义：
  * 左上角为(0, 0)点
  * 横向向右为X轴，取值范围：0~127
  * 纵向向下为Y轴，取值范围：0~63
  * 
  *       0             X轴           127 
  *      .------------------------------->
  *    0 |
  *      |
  *      |
  *      |
  *  Y轴 |
  *      |
  *      |
  *      |
  *   63 |
  *      v
  * 
  */


/*全局变量*********************/

const uint8 OLED_F8x16[][16] =
{
    {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00//   0
    },
    {
    0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00// ! 1
    },
    {
    0x00,0x16,0x0E,0x00,0x16,0x0E,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00// " 2
    },
    {
    0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,
    0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00// # 3
    },
    {
    0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,
    0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00// $ 4
    },
    {
    0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,
    0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00// % 5
    },
    {
    0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,
    0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10// & 6
    },
    {
    0x00,0x00,0x00,0x16,0x0E,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00// ' 7
    },
    {
    0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,
    0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00// ( 8
    },
    {
    0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,
    0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00// ) 9
    },
    {
    0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,
    0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00// * 10
    },
    {
    0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,
    0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00// + 11
    },
    {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0xB0,0x70,0x00,0x00,0x00,0x00,0x00// , 12
    },
    {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01// - 13
    },
    {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00// . 14
    },
    {
    0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,
    0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00// / 15
    },
    {
    0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,
    0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00// 0 16
    },
    {
    0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,
    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00// 1 17
    },
    {
    0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,
    0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00// 2 18
    },
    {
    0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,
    0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00// 3 19
    },
    {
    0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,
    0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00// 4 20
    },
    {
    0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,
    0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00// 5 21
    },
    {
    0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,
    0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00// 6 22
    },
    {
    0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,
    0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00// 7 23
    },
    {
    0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,
    0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00// 8 24
    },
    {
    0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,
    0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00// 9 25
    },
    {
    0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,
    0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00// : 26
    },
    {
    0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,
    0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00// ; 27
    },
    {
    0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,
    0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00// < 28
    },
    {
    0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,
    0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00// = 29
    },
    {
    0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,
    0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00// > 30
    },
    {
    0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,
    0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00// ? 31
    },
    {
    0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,
    0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00// @ 32
    },
    {
    0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,
    0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20// A 33
    },
    {
    0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,
    0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00// B 34
    },
    {
    0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,
    0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00// C 35
    },
    {
    0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,
    0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00// D 36
    },
    {
    0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,
    0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00// E 37
    },
    {
    0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,
    0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00// F 38
    },
    {
    0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,
    0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00// G 39
    },
    {
    0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,
    0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20// H 40
    },
    {
    0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,
    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00// I 41
    },
    {
    0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,
    0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00// J 42
    },
    {
    0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,
    0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00// K 43
    },
    {
    0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,
    0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00// L 44
    },
    {
    0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,
    0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00// M 45
    },
    {
    0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,
    0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00// N 46
    },
    {
    0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,
    0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00// O 47
    },
    {
    0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,
    0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00// P 48
    },
    {
    0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,
    0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00// Q 49
    },
    {
    0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,
    0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20// R 50
    },
    {
    0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,
    0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00// S 51
    },
    {
    0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,
    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00// T 52
    },
    {
    0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,
    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00// U 53
    },
    {
    0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,
    0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00// V 54
    },
    {
    0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,
    0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00// W 55
    },
    {
    0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,
    0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20// X 56
    },
    {
    0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,
    0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00// Y 57
    },
    {
    0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,
    0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00// Z 58
    },
    {
    0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,
    0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00// [ 59
    },
    {
    0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00// \ 60
    },
    {
    0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,
    0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00// ] 61
    },
    {
    0x00,0x20,0x10,0x08,0x04,0x08,0x10,0x20,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00// ^ 62
    },
    {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80// _ 63
    },
    {
    0x00,0x02,0x04,0x08,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00// ` 64
    },
    {
    0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
    0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20// a 65
    },
    {
    0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,
    0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00// b 66
    },
    {
    0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,
    0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00// c 67
    },
    {
    0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,
    0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20// d 68
    },
    {
    0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
    0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00// e 69
    },
    {
    0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,
    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00// f 70
    },
    {
    0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
    0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00// g 71
    },
    {
    0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,
    0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20// h 72
    },
    {
    0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,
    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00// i 73
    },
    {
    0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,
    0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00// j 74
    },
    {
    0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,
    0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00// k 75
    },
    {
    0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,
    0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00// l 76
    },
    {
    0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
    0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F// m 77
    },
    {
    0x00,0x80,0x80,0x00,0x80,0x80,0x00,0x00,
    0x00,0x20,0x3F,0x21,0x00,0x20,0x3F,0x20// n 78
    },
    {
    0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
    0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00// o 79
    },
    {
    0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,
    0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00// p 80
    },
    {
    0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,
    0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80// q 81
    },
    {
    0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,
    0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00// r 82
    },
    {
    0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
    0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00// s 83
    },
    {
    0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,
    0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00// t 84
    },
    {
    0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,
    0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20// u 85
    },
    {
    0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,
    0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00// v 86
    },
    {
    0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,
    0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00// w 87
    },
    {
    0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,
    0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00// x 88
    },
    {
    0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,
    0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00// y 89
    },
    {
    0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
    0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00// z 90
    },
    {
    0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,
    0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40// { 91
    },
    {
    0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00// | 92
    },
    {
    0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,
    0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00// } 93
    },
    {
    0x00,0x80,0x40,0x40,0x80,0x00,0x00,0x80,
    0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00// ~ 94
    }
};

/*宽6像素，高8像素*/
const uint8 OLED_F6x8[][6] =
{
    {0x00,0x00,0x00,0x00,0x00,0x00},//   0
    {0x00,0x00,0x00,0x2F,0x00,0x00},// ! 1
    {0x00,0x00,0x07,0x00,0x07,0x00},// " 2
    {0x00,0x14,0x7F,0x14,0x7F,0x14},// # 3
    {0x00,0x24,0x2A,0x7F,0x2A,0x12},// $ 4
    {0x00,0x23,0x13,0x08,0x64,0x62},// % 5
    {0x00,0x36,0x49,0x55,0x22,0x50},// & 6
    {0x00,0x00,0x00,0x07,0x00,0x00},// ' 7
    {0x00,0x00,0x1C,0x22,0x41,0x00},// ( 8
    {0x00,0x00,0x41,0x22,0x1C,0x00},// ) 9
    {0x00,0x14,0x08,0x3E,0x08,0x14},// * 10
    {0x00,0x08,0x08,0x3E,0x08,0x08},// + 11
    {0x00,0x00,0x00,0xA0,0x60,0x00},// , 12
    {0x00,0x08,0x08,0x08,0x08,0x08},// - 13
    {0x00,0x00,0x60,0x60,0x00,0x00},// . 14
    {0x00,0x20,0x10,0x08,0x04,0x02},// / 15
    {0x00,0x3E,0x51,0x49,0x45,0x3E},// 0 16
    {0x00,0x00,0x42,0x7F,0x40,0x00},// 1 17
    {0x00,0x42,0x61,0x51,0x49,0x46},// 2 18
    {0x00,0x21,0x41,0x45,0x4B,0x31},// 3 19
    {0x00,0x18,0x14,0x12,0x7F,0x10},// 4 20
    {0x00,0x27,0x45,0x45,0x45,0x39},// 5 21
    {0x00,0x3C,0x4A,0x49,0x49,0x30},// 6 22
    {0x00,0x01,0x71,0x09,0x05,0x03},// 7 23
    {0x00,0x36,0x49,0x49,0x49,0x36},// 8 24
    {0x00,0x06,0x49,0x49,0x29,0x1E},// 9 25
    {0x00,0x00,0x36,0x36,0x00,0x00},// : 26
    {0x00,0x00,0x56,0x36,0x00,0x00},// ; 27
    {0x00,0x08,0x14,0x22,0x41,0x00},// < 28
    {0x00,0x14,0x14,0x14,0x14,0x14},// = 29
    {0x00,0x00,0x41,0x22,0x14,0x08},// > 30
    {0x00,0x02,0x01,0x51,0x09,0x06},// ? 31
    {0x00,0x3E,0x49,0x55,0x59,0x2E},// @ 32
    {0x00,0x7C,0x12,0x11,0x12,0x7C},// A 33
    {0x00,0x7F,0x49,0x49,0x49,0x36},// B 34
    {0x00,0x3E,0x41,0x41,0x41,0x22},// C 35
    {0x00,0x7F,0x41,0x41,0x22,0x1C},// D 36
    {0x00,0x7F,0x49,0x49,0x49,0x41},// E 37
    {0x00,0x7F,0x09,0x09,0x09,0x01},// F 38
    {0x00,0x3E,0x41,0x49,0x49,0x7A},// G 39
    {0x00,0x7F,0x08,0x08,0x08,0x7F},// H 40
    {0x00,0x00,0x41,0x7F,0x41,0x00},// I 41
    {0x00,0x20,0x40,0x41,0x3F,0x01},// J 42
    {0x00,0x7F,0x08,0x14,0x22,0x41},// K 43
    {0x00,0x7F,0x40,0x40,0x40,0x40},// L 44
    {0x00,0x7F,0x02,0x0C,0x02,0x7F},// M 45
    {0x00,0x7F,0x04,0x08,0x10,0x7F},// N 46
    {0x00,0x3E,0x41,0x41,0x41,0x3E},// O 47
    {0x00,0x7F,0x09,0x09,0x09,0x06},// P 48
    {0x00,0x3E,0x41,0x51,0x21,0x5E},// Q 49
    {0x00,0x7F,0x09,0x19,0x29,0x46},// R 50
    {0x00,0x46,0x49,0x49,0x49,0x31},// S 51
    {0x00,0x01,0x01,0x7F,0x01,0x01},// T 52
    {0x00,0x3F,0x40,0x40,0x40,0x3F},// U 53
    {0x00,0x1F,0x20,0x40,0x20,0x1F},// V 54
    {0x00,0x3F,0x40,0x38,0x40,0x3F},// W 55
    {0x00,0x63,0x14,0x08,0x14,0x63},// X 56
    {0x00,0x07,0x08,0x70,0x08,0x07},// Y 57
    {0x00,0x61,0x51,0x49,0x45,0x43},// Z 58
    {0x00,0x00,0x7F,0x41,0x41,0x00},// [ 59
    {0x00,0x02,0x04,0x08,0x10,0x20},// \ 60
    {0x00,0x00,0x41,0x41,0x7F,0x00},// ] 61
    {0x00,0x04,0x02,0x01,0x02,0x04},// ^ 62
    {0x00,0x40,0x40,0x40,0x40,0x40},// _ 63
    {0x00,0x00,0x01,0x02,0x04,0x00},// ` 64
    {0x00,0x20,0x54,0x54,0x54,0x78},// a 65
    {0x00,0x7F,0x48,0x44,0x44,0x38},// b 66
    {0x00,0x38,0x44,0x44,0x44,0x20},// c 67
    {0x00,0x38,0x44,0x44,0x48,0x7F},// d 68
    {0x00,0x38,0x54,0x54,0x54,0x18},// e 69
    {0x00,0x08,0x7E,0x09,0x01,0x02},// f 70
    {0x00,0x18,0xA4,0xA4,0xA4,0x7C},// g 71
    {0x00,0x7F,0x08,0x04,0x04,0x78},// h 72
    {0x00,0x00,0x44,0x7D,0x40,0x00},// i 73
    {0x00,0x40,0x80,0x84,0x7D,0x00},// j 74
    {0x00,0x7F,0x10,0x28,0x44,0x00},// k 75
    {0x00,0x00,0x41,0x7F,0x40,0x00},// l 76
    {0x00,0x7C,0x04,0x18,0x04,0x78},// m 77
    {0x00,0x7C,0x08,0x04,0x04,0x78},// n 78
    {0x00,0x38,0x44,0x44,0x44,0x38},// o 79
    {0x00,0xFC,0x24,0x24,0x24,0x18},// p 80
    {0x00,0x18,0x24,0x24,0x18,0xFC},// q 81
    {0x00,0x7C,0x08,0x04,0x04,0x08},// r 82
    {0x00,0x48,0x54,0x54,0x54,0x20},// s 83
    {0x00,0x04,0x3F,0x44,0x40,0x20},// t 84
    {0x00,0x3C,0x40,0x40,0x20,0x7C},// u 85
    {0x00,0x1C,0x20,0x40,0x20,0x1C},// v 86
    {0x00,0x3C,0x40,0x30,0x40,0x3C},// w 87
    {0x00,0x44,0x28,0x10,0x28,0x44},// x 88
    {0x00,0x1C,0xA0,0xA0,0xA0,0x7C},// y 89
    {0x00,0x44,0x64,0x54,0x4C,0x44},// z 90
    {0x00,0x00,0x08,0x7F,0x41,0x00},// { 91
    {0x00,0x00,0x00,0x7F,0x00,0x00},// | 92
    {0x00,0x00,0x41,0x7F,0x08,0x00},// } 93
    {0x00,0x08,0x04,0x08,0x10,0x08}// ~ 94
};

/*汉字字模数据*********************/

/*相同的汉字只需要定义一次，汉字不分先后顺序*/
/*必须全部为汉字或者全角字符，不要加入任何半角字符*/

///*宽16像素，高16像素*/
const ChineseCell_t OLED_CF16x16[] = {


{{0x00,0x20,0x38,0xA6,0x60,0x18,0x00,0xF8,0x48,0x4A,0x4C,0x48,0x48,0x78,0x00,0x00,0x00,0x22,0x23,0x22,0x12,0x12,0x04,0x7F,0x09,0x3F,0x09,0x3F,0x49,0x7F,0x00,0x00},"编"},//0
{{0x00,0x10,0x90,0xFE,0x90,0x50,0x44,0x44,0x44,0xC4,0x44,0x44,0x44,0x40,0x00,0x00,0x00,0x02,0x01,0x7F,0x00,0x11,0x0C,0x43,0x40,0x7F,0x00,0x01,0x06,0x18,0x00,0x00},"标"},//1
{{0x00,0x40,0x84,0x08,0x10,0x00,0xF8,0x88,0x88,0x88,0xFE,0x88,0x88,0x38,0x00,0x00,0x00,0x00,0x30,0x0C,0x43,0x30,0x4F,0x40,0x23,0x2C,0x10,0x28,0x47,0x40,0x00,0x00},"波"},//2
{{0x00,0x10,0x10,0xFE,0x10,0x08,0xE8,0x28,0x28,0xFE,0x28,0x2A,0xEC,0x08,0x00,0x00,0x00,0x42,0x42,0x7F,0x01,0x00,0x7F,0x09,0x09,0x3F,0x09,0x49,0x7F,0x00,0x00,0x00},"捕"},//3
{{0x00,0x00,0x7C,0x40,0x40,0x40,0x40,0xFE,0x40,0x40,0x40,0x40,0x7C,0x00,0x00,0x00,0x00,0x3E,0x20,0x20,0x20,0x20,0x20,0x3F,0x20,0x20,0x20,0x20,0x20,0x7E,0x00,0x00},"出"},//4
{{0x00,0x00,0x78,0x48,0x48,0x48,0x48,0xFE,0x48,0x48,0x48,0x48,0x78,0x00,0x00,0x00,0x00,0x1F,0x09,0x09,0x09,0x09,0x09,0x7F,0x09,0x09,0x09,0x09,0x09,0x1F,0x00,0x00},"串"},//5
{{0x00,0x20,0x20,0x20,0x20,0x20,0xA0,0x7E,0xA0,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x40,0x40,0x20,0x10,0x0C,0x03,0x00,0x03,0x0C,0x10,0x20,0x40,0x40,0x00,0x00},"大"},//6
{{0x00,0x10,0x88,0xC4,0x32,0x00,0xBE,0xAA,0xAA,0xAA,0xAA,0xAA,0xBE,0x00,0x00,0x00,0x00,0x01,0x00,0x7F,0x00,0x02,0x0A,0x12,0x02,0x42,0x42,0x7F,0x02,0x02,0x00,0x00},"得"},//7
{{0x00,0x18,0x08,0x48,0x48,0x48,0x4A,0xCC,0x48,0x48,0x48,0x48,0x08,0x18,0x00,0x00,0x00,0x40,0x20,0x1E,0x20,0x40,0x40,0x7F,0x44,0x44,0x44,0x44,0x40,0x40,0x00,0x00},"定"},//8
{{0x00,0x40,0x44,0xC4,0x44,0x44,0x40,0x10,0x10,0xFE,0x10,0x10,0x10,0xF0,0x00,0x00,0x00,0x08,0x0E,0x09,0x08,0x0A,0x5C,0x20,0x18,0x07,0x00,0x40,0x40,0x3F,0x00,0x00},"动"},//9
{{0x00,0x00,0x00,0xF8,0x28,0x28,0xF8,0xAA,0xAC,0xA8,0xA8,0xF8,0x28,0x28,0x00,0x00,0x00,0x40,0x30,0x0F,0x40,0x42,0x26,0x2A,0x12,0x12,0x2A,0x26,0x42,0x40,0x00,0x00},"度"},//10
{{0x00,0x00,0x00,0xFC,0x24,0xE4,0x24,0x24,0x24,0x22,0x22,0xE2,0x02,0x00,0x00,0x00,0x00,0x20,0x18,0x47,0x40,0x20,0x23,0x14,0x08,0x14,0x23,0x20,0x40,0x40,0x00,0x00},"反"},//11
{{0x00,0x80,0x40,0xA0,0x98,0x86,0x80,0x80,0x80,0x86,0x98,0x20,0x40,0x80,0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x07,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,0x00},"分"},//12
{{0x00,0x00,0xFE,0x02,0x12,0x22,0x42,0x82,0x62,0x1A,0x02,0xFE,0x00,0x00,0x00,0x00,0x00,0x40,0x3F,0x00,0x10,0x08,0x06,0x01,0x06,0x18,0x00,0x1F,0x20,0x78,0x00,0x00},"风"},//13
{{0x00,0x10,0x90,0xFE,0x90,0x10,0x20,0x10,0xAE,0x48,0xA8,0x18,0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x7F,0x00,0x01,0x02,0x7D,0x24,0x24,0x24,0x7D,0x02,0x02,0x00,0x00},"格"},//14
{{0x00,0x00,0x10,0x10,0x12,0x1C,0x10,0xF0,0x10,0x18,0x16,0x10,0x10,0x00,0x00,0x00,0x00,0x41,0x41,0x21,0x11,0x09,0x07,0x01,0x07,0x09,0x11,0x21,0x41,0x41,0x00,0x00},"关"},//15
{{0x00,0x40,0x44,0x48,0x50,0xC0,0x40,0x7E,0x40,0xC0,0x50,0x48,0x44,0x40,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,0x3F,0x40,0x40,0x40,0x70,0x00,0x00},"光"},//16
{{0x00,0x02,0xE2,0x02,0xF2,0x92,0x92,0xF2,0x92,0x92,0xF2,0x02,0xE2,0x02,0x00,0x00,0x00,0x00,0x3F,0x20,0x2F,0x28,0x28,0x2F,0x28,0x28,0x2F,0x20,0x7F,0x00,0x00,0x00},"画"},//17
{{0x00,0x08,0x08,0x08,0xE8,0x1E,0x88,0x08,0xE8,0x08,0x08,0x08,0x88,0x08,0x00,0x00,0x00,0x08,0x04,0x43,0x40,0x22,0x11,0x0C,0x03,0x0C,0x12,0x21,0x40,0x40,0x00,0x00},"灰"},//18
{{0x00,0x04,0xA4,0x44,0xA4,0x0E,0x04,0x04,0x04,0xEE,0x04,0x24,0x44,0x04,0x00,0x00,0x00,0x09,0x44,0x42,0x3F,0x40,0x21,0x11,0x0D,0x03,0x0D,0x11,0x21,0x41,0x00,0x00},"获"},//19
{{0x00,0x10,0x90,0xFE,0x90,0x10,0x00,0xFC,0x04,0x04,0x04,0xFC,0x00,0x00,0x00,0x00,0x00,0x02,0x01,0x7F,0x00,0x41,0x30,0x0F,0x00,0x00,0x00,0x3F,0x40,0x70,0x00,0x00},"机"},//20
{{0x00,0x10,0x10,0x10,0xFE,0x10,0x10,0xF0,0x00,0xF0,0x10,0x10,0x10,0xF0,0x00,0x00,0x00,0x40,0x30,0x0E,0x01,0x40,0x40,0x3F,0x00,0x3F,0x10,0x10,0x10,0x3F,0x00,0x00},"加"},//21
{{0x00,0x30,0xA8,0x66,0x30,0x08,0x48,0x48,0x48,0x7E,0x48,0x48,0x48,0x08,0x00,0x00,0x00,0x23,0x22,0x12,0x12,0x00,0x7E,0x22,0x22,0x22,0x22,0x22,0x7E,0x00,0x00,0x00},"结"},//22
{{0x00,0x10,0x0E,0xF8,0x08,0x08,0x00,0xFC,0x44,0x44,0x44,0x44,0xC4,0x04,0x00,0x00,0x00,0x41,0x39,0x07,0x09,0x31,0x00,0x7F,0x44,0x44,0x44,0x44,0x47,0x40,0x00,0x00},"矩"},//23
{{0x00,0x00,0x00,0xF8,0x88,0xA8,0xA8,0xAA,0xFC,0xA8,0xA8,0xE8,0x88,0x88,0x00,0x00,0x00,0x40,0x30,0x0F,0x40,0x2A,0x12,0x42,0x7F,0x0A,0x12,0x2B,0x44,0x40,0x00,0x00},"康"},//24
{{0x00,0x00,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x3F,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x00,0x00},"口"},//25
{{0x00,0xE0,0x00,0xFE,0x10,0x20,0x08,0x08,0xFE,0x08,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x41,0x21,0x19,0x07,0x01,0x07,0x19,0x21,0x41,0x00,0x00},"快"},//26
{{0x00,0x44,0x28,0x10,0xEE,0x00,0xF8,0x48,0x4A,0x4C,0x48,0x48,0xF8,0x00,0x00,0x00,0x00,0x04,0x42,0x41,0x3F,0x00,0x7F,0x22,0x12,0x06,0x0A,0x12,0x2B,0x44,0x00,0x00},"狼"},//27
{{0x00,0x08,0xC8,0xB8,0x88,0x88,0x04,0xF4,0x84,0x84,0x84,0xFC,0x80,0x80,0x00,0x00,0x00,0x01,0x3F,0x10,0x10,0x3F,0x04,0x04,0x04,0x04,0x04,0x44,0x40,0x3F,0x00,0x00},"码"},//28
{{0x00,0xE0,0x00,0xFE,0x10,0x20,0x80,0xBE,0xAA,0xAA,0xAA,0xAA,0xBE,0x80,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x43,0x4A,0x5B,0x2A,0x2A,0x5B,0x4A,0x43,0x00,0x00},"慢"},//29
{{0x00,0x20,0x20,0x10,0x10,0x28,0x24,0x22,0x24,0x28,0x10,0x10,0x20,0x20,0x00,0x00,0x00,0x00,0x3F,0x11,0x11,0x11,0x3F,0x00,0x7F,0x01,0x21,0x21,0x3F,0x00,0x00,0x00},"命"},//30
{{0x00,0xF8,0x08,0x08,0xF8,0x40,0x48,0xF8,0x44,0x40,0xFE,0x40,0x44,0x58,0x00,0x00,0x00,0x0F,0x04,0x04,0x0F,0x44,0x44,0x7F,0x02,0x40,0x23,0x1C,0x27,0x78,0x00,0x00},"哦"},//31
{{0x00,0x80,0x9E,0x92,0x92,0x92,0x9E,0xC0,0x9E,0x92,0xB2,0xD2,0x9E,0x80,0x00,0x00,0x00,0x04,0x7C,0x4A,0x4A,0x49,0x78,0x00,0x78,0x49,0x4A,0x4A,0x7C,0x04,0x00,0x00},"器"},//32
{{0x00,0x00,0x00,0x00,0x00,0x02,0xCC,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x10,0x0C,0x03,0x00,0x00,0x00,0x03,0x0C,0x10,0x20,0x40,0x00,0x00},"入"},//33
{{0x00,0x80,0x60,0x1C,0x10,0x10,0x10,0xFE,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x40,0x40,0x42,0x42,0x42,0x42,0x7F,0x42,0x42,0x42,0x42,0x40,0x40,0x00,0x00},"生"},//34
{{0x00,0xF8,0x88,0x88,0xF8,0x00,0x10,0x90,0x10,0x10,0x10,0xFE,0x10,0x10,0x00,0x00,0x00,0x1F,0x08,0x08,0x1F,0x00,0x00,0x00,0x03,0x40,0x40,0x7F,0x00,0x00,0x00,0x00},"时"},//35
{{0x00,0x40,0x40,0x44,0x44,0x44,0x44,0xC4,0x44,0x44,0x44,0x44,0x40,0x40,0x00,0x00,0x00,0x10,0x08,0x04,0x03,0x40,0x40,0x7F,0x00,0x00,0x01,0x02,0x04,0x18,0x00,0x00},"示"},//36
{{0x00,0xE8,0x9E,0xC8,0x88,0x20,0x90,0xA8,0xA4,0xA2,0x24,0x28,0x10,0xA0,0x00,0x00,0x00,0x08,0x08,0x7F,0x04,0x00,0x7F,0x0A,0x4A,0x7F,0x00,0x5F,0x40,0x7F,0x00,0x00},"输"},//37
{{0x00,0x00,0x7C,0x54,0x54,0x52,0x50,0x40,0x50,0x54,0x54,0x54,0x7C,0x00,0x00,0x00,0x00,0x00,0x7F,0x24,0x09,0x02,0x7F,0x20,0x09,0x12,0x00,0x1F,0x20,0x78,0x00,0x00},"鼠"},//38
{{0x00,0x08,0xC8,0x48,0x48,0x48,0x48,0xFE,0x48,0x48,0x48,0x48,0xC8,0x08,0x00,0x00,0x00,0x20,0x23,0x12,0x0A,0x06,0x02,0x7F,0x02,0x06,0x0A,0x12,0x23,0x20,0x00,0x00},"束"},//39
{{0x00,0x80,0x84,0x98,0x00,0x08,0xE8,0x28,0x28,0xFE,0x28,0x28,0xE8,0x08,0x00,0x00,0x00,0x40,0x20,0x1F,0x20,0x50,0x49,0x45,0x43,0x7F,0x43,0x45,0x49,0x50,0x00,0x00},"速"},//40
{{0x00,0x80,0x84,0x98,0x00,0x00,0xFC,0x54,0xD4,0x54,0x54,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x20,0x1F,0x20,0x40,0x5F,0x48,0x44,0x41,0x42,0x45,0x58,0x40,0x00,0x00},"退"},//41
{{0x00,0x00,0xF8,0x28,0x28,0xE8,0x28,0x28,0x08,0xFE,0x08,0x0A,0xCC,0x08,0x00,0x00,0x00,0x20,0x1F,0x21,0x17,0x09,0x09,0x57,0x20,0x13,0x0C,0x13,0x20,0x78,0x00,0x00},"威"},//42
{{0x00,0x00,0x48,0x88,0x08,0xC8,0x38,0x40,0x40,0xFE,0x20,0x22,0xAC,0x20,0x00,0x00,0x00,0x20,0x10,0x0C,0x03,0x06,0x18,0x40,0x20,0x17,0x08,0x16,0x21,0x78,0x00,0x00},"戏"},//43
{{0x00,0x10,0x10,0xD0,0xFE,0x90,0x10,0x00,0xFC,0x44,0x44,0x44,0x44,0xFC,0x00,0x00,0x00,0x04,0x03,0x00,0x7F,0x00,0x01,0x00,0x7F,0x22,0x22,0x22,0x22,0x7F,0x00,0x00},"相"},//44
{{0x00,0x80,0x84,0xFC,0x84,0x84,0xFC,0x84,0x80,0x20,0x10,0x88,0x66,0x00,0x00,0x00,0x00,0x40,0x20,0x1F,0x00,0x00,0x7F,0x00,0x00,0x42,0x21,0x10,0x08,0x06,0x00,0x00},"形"},//45
{{0x00,0x20,0x44,0x08,0x00,0xF0,0x10,0x10,0x10,0xFE,0x10,0x10,0x10,0xF0,0x00,0x00,0x00,0x30,0x0C,0x03,0x00,0x7F,0x21,0x21,0x21,0x3F,0x21,0x21,0x21,0x7F,0x00,0x00},"油"},//46
{{0x00,0x40,0x84,0x08,0x00,0x10,0xF2,0x94,0x90,0x20,0x5E,0x48,0xC8,0x08,0x00,0x00,0x00,0x00,0x30,0x0C,0x43,0x30,0x0F,0x20,0x3F,0x02,0x42,0x7F,0x02,0x02,0x00,0x00},"游"},//47
{{0x00,0x00,0xF8,0x08,0x08,0x08,0x08,0xFE,0x08,0x08,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x07,0x02,0x02,0x02,0x02,0x7F,0x02,0x02,0x02,0x02,0x07,0x00,0x00,0x00},"中"},//48



/*未找到指定汉字时显示的默认图形（一个方框，内部一个问号），请确保其位于数组最末尾*/
{{0xFF,0x01,0x01,0x01,0x31,0x09,0x09,0x09,0x09,0x89,0x71,0x01,0x01,0x01,0x01,0xFF,
0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x96,0x81,0x80,0x80,0x80,0x80,0x80,0x80,0xFF},""}
};
/*********************汉字字模数据*/

/**
  * OLED显存数组
  * 所有的显示函数，都只是对此显存数组进行读写
  * 随后调用OLED_Update函数或OLED_UpdateArea函数
  * 才会将显存数组的数据发送到OLED硬件，进行显示
  */
uint8 OLED_DisplayBuf[8][128];

/*********************全局变量*/

/*I2C通信函数*/

void _OLED_GPIO_Init(void)
{
    /*I2C初始化*/
    OLED_I2C_Struct.scl_port = I2C_SCL_I2C_PIN.pin.port;
    OLED_I2C_Struct.scl_pin = I2C_SCL_I2C_PIN.pin.pinIndex;

    OLED_I2C_Struct.sda_port = I2C_SDA_I2C_PIN.pin.port;
    OLED_I2C_Struct.sda_pin = I2C_SDA_I2C_PIN.pin.pinIndex;

    OLED_I2C_Struct.status = EI2C_NOT_READY;
    /*I2C初始化*/
    EI2C_Init(&OLED_I2C_Struct);
}

/**
  * 函    数：OLED写入命令
  * 参    数：Command 指令
  * 返 回 值：无
  * 说    明：此函数用于向OLED发送指令
  */
void _OLED_WriteCommand(uint8 Command)
{
    EI2C_Mem_Write(&OLED_I2C_Struct, OLED_I2C_ADDRESS, 0x00, &Command, 1);
}

/**
  * 函    数：OLED写入数据
  * 参    数：Data 数据
  * 参    数：Length 数据长度
  * 返 回 值：无
  * 说    明：此函数用于向OLED发送数据
  */
void _OLED_WriteData(uint8 *Data, uint16 Length)
{
    EI2C_Mem_Write(&OLED_I2C_Struct, OLED_I2C_ADDRESS, 0x40, Data, Length);
}

/*硬件配置*********************/

/**
  * 函    数：OLED初始化
  * 参    数：无
  * 返 回 值：无
  * 说    明：使用前，需要调用此初始化函数
  */
void OLED_Init(void)
{
	_OLED_GPIO_Init();			//先调用底层的端口初始化
	
	/*写入一系列的命令，对OLED进行初始化配置*/
	_OLED_WriteCommand(0xAE);	//设置显示开启/关闭，0xAE关闭，0xAF开启
	
	_OLED_WriteCommand(0xD5);	//设置显示时钟分频比/振荡器频率
	_OLED_WriteCommand(0x80);	//0x00~0xFF
	
	_OLED_WriteCommand(0xA8);	//设置多路复用率
	_OLED_WriteCommand(0x3F);	//0x0E~0x3F
	
	_OLED_WriteCommand(0xD3);	//设置显示偏移
	_OLED_WriteCommand(0x00);	//0x00~0x7F
	
	_OLED_WriteCommand(0x40);	//设置显示开始行，0x40~0x7F
	
	_OLED_WriteCommand(0xA1);	//设置左右方向，0xA1正常，0xA0左右反置
	
	_OLED_WriteCommand(0xC8);	//设置上下方向，0xC8正常，0xC0上下反置

	_OLED_WriteCommand(0xDA);	//设置COM引脚硬件配置
	_OLED_WriteCommand(0x12);
	
	_OLED_WriteCommand(0x81);	//设置对比度
	_OLED_WriteCommand(0xCF);	//0x00~0xFF

	_OLED_WriteCommand(0xD9);	//设置预充电周期
	_OLED_WriteCommand(0xF1);

	_OLED_WriteCommand(0xDB);	//设置VCOMH取消选择级别
	_OLED_WriteCommand(0x30);

	_OLED_WriteCommand(0xA4);	//设置整个显示打开/关闭

	_OLED_WriteCommand(0xA6);	//设置正常/反色显示，0xA6正常，0xA7反色

	_OLED_WriteCommand(0x8D);	//设置充电泵
	_OLED_WriteCommand(0x14);

	_OLED_WriteCommand(0xAF);	//开启显示
	
	OLED_Clear();				//清空显存数组
	OLED_Update();				//更新显示，清屏，防止初始化后未显示内容时花屏
}

/**
  * 函    数：OLED设置显示光标位置
  * 参    数：Page 指定光标所在的页，范围：0~7
  * 参    数：X 指定光标所在的X轴坐标，范围：0~127
  * 返 回 值：无
  * 说    明：OLED默认的Y轴，只能8个Bit为一组写入，即1页等于8个Y轴坐标
  */
void _OLED_SetCursor(uint8 Page, uint8 X)
{
	/*如果使用此程序驱动1.3寸的OLED显示屏，则需要解除此注释*/
	/*因为1.3寸的OLED驱动芯片（SH1106）有132列*/
	/*屏幕的起始列接在了第2列，而不是第0列*/
	/*所以需要将X加2，才能正常显示*/
//	X += 2;
	
	/*通过指令设置页地址和列地址*/
	_OLED_WriteCommand(0xB0 | Page);					//设置页位置
	_OLED_WriteCommand(0x10 | ((X & 0xF0) >> 4));	//设置X位置高4位
	_OLED_WriteCommand(0x00 | (X & 0x0F));			//设置X位置低4位
}

/*********************硬件配置*/


/*工具函数*********************/

/*工具函数仅供内部部分函数使用*/

/**
  * 函    数：次方函数
  * 参    数：X 底数
  * 参    数：Y 指数
  * 返 回 值：等于X的Y次方
  */
uint32 _OLED_Pow(uint32 X, uint32 Y)
{
	uint32 Result = 1;	//结果默认为1
	while (Y --)			//累乘Y次
	{
		Result *= X;		//每次把X累乘到结果上
	}
	return Result;
}

/**
  * 函    数：判断指定点是否在指定多边形内部
  * 参    数：nvert 多边形的顶点数
  * 参    数：vertx verty 包含多边形顶点的x和y坐标的数组
  * 参    数：testx testy 测试点的X和y坐标
  * 返 回 值：指定点是否在指定多边形内部，1：在内部，0：不在内部
  */
uint8 _OLED_pnpoly(uint8 nvert, uint16 *vertx, uint16 *verty, uint16 testx, uint16 testy)
{
	uint16 i, j, c = 0;
	
	/*此算法由W. Randolph Franklin提出*/
	/*参考链接：https://wrfranklin.org/Research/Short_Notes/pnpoly.html*/
	for (i = 0, j = nvert - 1; i < nvert; j = i++)
	{
		if (((verty[i] > testy) != (verty[j] > testy)) &&
			(testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]))
		{
			c = !c;
		}
	}
	return (uint8)c;
}

/**
  * 函    数：判断指定点是否在指定角度内部
  * 参    数：X Y 指定点的坐标
  * 参    数：StartAngle EndAngle 起始角度和终止角度，范围：-180~180
  *           水平向右为0度，水平向左为180度或-180度，下方为正数，上方为负数，顺时针旋转
  * 返 回 值：指定点是否在指定角度内部，1：在内部，0：不在内部
  */
uint8 _OLED_IsInAngle(uint16 X, uint16 Y, uint16 StartAngle, uint16 EndAngle)
{
	uint16 PointAngle;
	PointAngle = atan2(Y, X) / 3.14 * 180;	//计算指定点的弧度，并转换为角度表示
	if (StartAngle < EndAngle)	//起始角度小于终止角度的情况
	{
		/*如果指定角度在起始终止角度之间，则判定指定点在指定角度*/
		if (PointAngle >= StartAngle && PointAngle <= EndAngle)
		{
			return 1;
		}
	}
	else			//起始角度大于于终止角度的情况
	{
		/*如果指定角度大于起始角度或者小于终止角度，则判定指定点在指定角度*/
		if (PointAngle >= StartAngle || PointAngle <= EndAngle)
		{
			return 1;
		}
	}
	return 0;		//不满足以上条件，则判断判定指定点不在指定角度
}

/*********************工具函数*/


/*功能函数*********************/

/**
  * 函    数：将OLED显存数组更新到OLED屏幕
  * 参    数：无
  * 返 回 值：无
  * 说    明：所有的显示函数，都只是对OLED显存数组进行读写
  *           随后调用OLED_Update函数或OLED_UpdateArea函数
  *           才会将显存数组的数据发送到OLED硬件，进行显示
  *           故调用显示函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_Update(void)
{
	//{OLED_Printf(128-6*6, 0, 6,"FPS %d", Get_FPS());	}	//显示帧率;解除注释开启
	
	uint8 j;
	/*遍历每一页*/
	for (j = 0; j < 8; j ++)
	{
		/*设置光标位置为每一页的第一列*/
		_OLED_SetCursor(j, 0);
		/*连续写入128个数据，将显存数组的数据写入到OLED硬件*/
		_OLED_WriteData(OLED_DisplayBuf[j], 128);
	}
}

/**
  * 函    数：将OLED显存数组部分更新到OLED屏幕
  * 参    数：X 指定区域左上角的横坐标，范围：0~127
  * 参    数：Y 指定区域左上角的纵坐标，范围：0~63
  * 参    数：Width 指定区域的宽度，范围：0~128
  * 参    数：Height 指定区域的高度，范围：0~64
  * 返 回 值：无
  * 说    明：此函数会至少更新参数指定的区域
  *           如果更新区域Y轴只包含部分页，则同一页的剩余部分会跟随一起更新
  * 说    明：所有的显示函数，都只是对OLED显存数组进行读写
  *           随后调用OLED_Update函数或OLED_UpdateArea函数
  *           才会将显存数组的数据发送到OLED硬件，进行显示
  *           故调用显示函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_UpdateArea(uint8 X, uint8 Y, uint8 Width, uint8 Height)
{
	uint8 j;
	
	/*参数检查，保证指定区域不会超出屏幕范围*/
	if (X > 127) {return;}
	if (Y > 63) {return;}
	if (X + Width > 128) {Width = 128 - X;}
	if (Y + Height > 64) {Height = 64 - Y;}
	
	/*遍历指定区域涉及的相关页*/
	/*(Y + Height - 1) / 8 + 1的目的是(Y + Height) / 8并向上取整*/
	for (j = Y / 8; j < (Y + Height - 1) / 8 + 1; j ++)
	{
		/*设置光标位置为相关页的指定列*/
		_OLED_SetCursor(j, X);
		/*连续写入Width个数据，将显存数组的数据写入到OLED硬件*/
		_OLED_WriteData(&OLED_DisplayBuf[j][X], Width);
	}
}

/**
  * 函    数：将OLED显存数组全部清零
  * 参    数：无
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_Clear(void)
{
	uint8 i, j;
	for (j = 0; j < 8; j ++)				//遍历8页
	{
		for (i = 0; i < 128; i ++)			//遍历128列
		{
			OLED_DisplayBuf[j][i] = 0x00;	//将显存数组数据全部清零
		}
	}
}

/**
  * 函    数：将OLED显存数组部分清零
  * 参    数：X 指定区域左上角的横坐标，范围：0~127
  * 参    数：Y 指定区域左上角的纵坐标，范围：0~63
  * 参    数：Width 指定区域的宽度，范围：0~128
  * 参    数：Height 指定区域的高度，范围：0~64
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ClearArea(uint8 X, uint8 Y, uint8 Width, uint8 Height)
{
	uint8 i, j;
	
	/*参数检查，保证指定区域不会超出屏幕范围*/
	if (X > 127) {return;}
	if (Y > 63) {return;}
	if (X + Width > 128) {Width = 128 - X;}
	if (Y + Height > 64) {Height = 64 - Y;}
	
	for (j = Y; j < Y + Height; j ++)		//遍历指定页
	{
		for (i = X; i < X + Width; i ++)	//遍历指定列
		{
			OLED_DisplayBuf[j / 8][i] &= ~(0x01 << (j % 8));	//将显存数组指定数据清零
		}
	}
}

/**
  * 函    数：将OLED显存数组全部取反
  * 参    数：无
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_Reverse(void)
{
	uint8 i, j;
	for (j = 0; j < 8; j ++)				//遍历8页
	{
		for (i = 0; i < 128; i ++)			//遍历128列
		{
			OLED_DisplayBuf[j][i] ^= 0xFF;	//将显存数组数据全部取反
		}
	}
}
	
/**
  * 函    数：将OLED显存数组部分取反
  * 参    数：X 指定区域左上角的横坐标，范围：0~127
  * 参    数：Y 指定区域左上角的纵坐标，范围：0~63
  * 参    数：Width 指定区域的宽度，范围：0~128
  * 参    数：Height 指定区域的高度，范围：0~64
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ReverseArea(uint8 X, uint8 Y, uint8 Width, uint8 Height)
{
	uint8 i, j;
	
	/*参数检查，保证指定区域不会超出屏幕范围*/
	if (X > 127) {return;}
	if (Y > 63) {return;}
	if (X + Width > 128) {Width = 128 - X;}
	if (Y + Height > 64) {Height = 64 - Y;}
	
	for (j = Y; j < Y + Height; j ++)		//遍历指定页
	{
		for (i = X; i < X + Width; i ++)	//遍历指定列
		{
			OLED_DisplayBuf[j / 8][i] ^= 0x01 << (j % 8);	//将显存数组指定数据取反
		}
	}
}

/**
  * 函    数：OLED显示一个字符
  * 参    数：X 指定字符左上角的横坐标，范围：0~127
  * 参    数：Y 指定字符左上角的纵坐标，范围：0~63
  * 参    数：Char 指定要显示的字符，范围：ASCII码可见字符
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowChar(uint8 X, uint8 Y, char Char, uint8 FontSize)
{
	if (FontSize == OLED_8X16)		//字体为宽8像素，高16像素
	{
		/*将ASCII字模库OLED_F8x16的指定数据以8*16的图像格式显示*/
		OLED_ShowImage(X, Y, 8, 16, OLED_F8x16[Char - ' ']);
	}
	else if(FontSize == OLED_6X8)	//字体为宽6像素，高8像素
	{
		/*将ASCII字模库OLED_F6x8的指定数据以6*8的图像格式显示*/
		OLED_ShowImage(X, Y, 6, 8, OLED_F6x8[Char - ' ']);
	}
}

/**
  * 函    数：OLED显示字符串
  * 参    数：X 指定字符串左上角的横坐标，范围：0~127
  * 参    数：Y 指定字符串左上角的纵坐标，范围：0~63
  * 参    数：String 指定要显示的字符串，范围：ASCII码可见字符组成的字符串
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowString(uint8 X, uint8 Y, char *String, uint8 FontSize)
{
	uint8 i;
	for (i = 0; String[i] != '\0'; i++)		//遍历字符串的每个字符
	{
		/*调用OLED_ShowChar函数，依次显示每个字符*/
		OLED_ShowChar(X + i * FontSize, Y, String[i], FontSize);
	}
}

/**
  * 函    数：OLED显示数字（十进制，正整数）
  * 参    数：X 指定数字左上角的横坐标，范围：0~127
  * 参    数：Y 指定数字左上角的纵坐标，范围：0~63
  * 参    数：Number 指定要显示的数字，范围：0~4294967295
  * 参    数：Length 指定数字的长度，范围：0~10
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowNum(uint8 X, uint8 Y, uint32 Number, uint8 Length, uint8 FontSize)
{
	uint8 i;
	for (i = 0; i < Length; i++)		//遍历数字的每一位							
	{
		/*调用OLED_ShowChar函数，依次显示每个数字*/
		/*Number / OLED_Pow(10, Length - i - 1) % 10 可以十进制提取数字的每一位*/
		/*+ '0' 可将数字转换为字符格式*/
		OLED_ShowChar(X + i * FontSize, Y, (char)(Number / _OLED_Pow(10, Length - i - 1) % 10 + '0'), FontSize);
	}
}

/**
  * 函    数：OLED显示有符号数字（十进制，整数）
  * 参    数：X 指定数字左上角的横坐标，范围：0~127
  * 参    数：Y 指定数字左上角的纵坐标，范围：0~63
  * 参    数：Number 指定要显示的数字，范围：-2147483648~2147483647
  * 参    数：Length 指定数字的长度，范围：0~10
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowSignedNum(uint8 X, uint8 Y, sint32 Number, uint8 Length, uint8 FontSize)
{
	uint8 i;
	int Number1;
	
	if (Number >= 0)						//数字大于等于0
	{
		OLED_ShowChar(X, Y, '+', FontSize);	//显示+号
		Number1 = Number;					//Number1直接等于Number
	}
	else									//数字小于0
	{
		OLED_ShowChar(X, Y, '-', FontSize);	//显示-号
		Number1 = -1 * Number;					//Number1等于Number取负
	}
	
	for (i = 0; i < Length; i++)			//遍历数字的每一位								
	{
		/*调用OLED_ShowChar函数，依次显示每个数字*/
		/*Number1 / OLED_Pow(10, Length - i - 1) % 10 可以十进制提取数字的每一位*/
		/*+ '0' 可将数字转换为字符格式*/
		OLED_ShowChar(X + (i + 1) * FontSize, Y, (char)(Number1 / _OLED_Pow(10, Length - i - 1) % 10) + '0', FontSize);
	}
}

/**
  * 函    数：OLED显示十六进制数字（十六进制，正整数）
  * 参    数：X 指定数字左上角的横坐标，范围：0~127
  * 参    数：Y 指定数字左上角的纵坐标，范围：0~63
  * 参    数：Number 指定要显示的数字，范围：0x00000000~0xFFFFFFFF
  * 参    数：Length 指定数字的长度，范围：0~8
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowHexNum(uint8 X, uint8 Y, uint32 Number, uint8 Length, uint8 FontSize)
{
	uint8 i, SingleNumber;
	for (i = 0; i < Length; i++)		//遍历数字的每一位
	{
		/*以十六进制提取数字的每一位*/
		SingleNumber = Number / _OLED_Pow(16, Length - i - 1) % 16;
		
		if (SingleNumber < 10)			//单个数字小于10
		{
			/*调用OLED_ShowChar函数，显示此数字*/
			/*+ '0' 可将数字转换为字符格式*/
			OLED_ShowChar(X + i * FontSize, Y, SingleNumber + '0', FontSize);
		}
		else							//单个数字大于10
		{
			/*调用OLED_ShowChar函数，显示此数字*/
			/*+ 'A' 可将数字转换为从A开始的十六进制字符*/
			OLED_ShowChar(X + i * FontSize, Y, SingleNumber - 10 + 'A', FontSize);
		}
	}
}

/**
  * 函    数：OLED显示二进制数字（二进制，正整数）
  * 参    数：X 指定数字左上角的横坐标，范围：0~127
  * 参    数：Y 指定数字左上角的纵坐标，范围：0~63
  * 参    数：Number 指定要显示的数字，范围：0x00000000~0xFFFFFFFF
  * 参    数：Length 指定数字的长度，范围：0~16
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowBinNum(uint8 X, uint8 Y, uint32 Number, uint8 Length, uint8 FontSize)
{
	uint8 i;
	for (i = 0; i < Length; i++)		//遍历数字的每一位	
	{
		/*调用OLED_ShowChar函数，依次显示每个数字*/
		/*Number / OLED_Pow(2, Length - i - 1) % 2 可以二进制提取数字的每一位*/
		/*+ '0' 可将数字转换为字符格式*/
		OLED_ShowChar(X + i * FontSize, Y, (char)(Number / _OLED_Pow(2, Length - i - 1) % 2) + '0', FontSize);
	}
}

/**
  * 函    数：OLED显示浮点数字（十进制，小数）
  * 参    数：X 指定数字左上角的横坐标，范围：0~127
  * 参    数：Y 指定数字左上角的纵坐标，范围：0~63
  * 参    数：Number 指定要显示的数字，范围：-4294967295.0~4294967295.0
  * 参    数：IntLength 指定数字的整数位长度，范围：0~10
  * 参    数：FraLength 指定数字的小数位长度，范围：0~9，小数进行四舍五入显示
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowFloatNum(uint8 X, uint8 Y, double Number, uint8 IntLength, uint8 FraLength, uint8 FontSize)
{
	uint32 PowNum, IntNum, FraNum;
	
	if (Number >= 0)						//数字大于等于0
	{
		OLED_ShowChar(X, Y, '+', FontSize);	//显示+号
	}
	else									//数字小于0
	{
		OLED_ShowChar(X, Y, '-', FontSize);	//显示-号
		Number = -Number;					//Number取负
	}
	
	/*提取整数部分和小数部分*/
	IntNum = Number;						//直接赋值给整型变量，提取整数
	Number -= IntNum;						//将Number的整数减掉，防止之后将小数乘到整数时因数过大造成错误
	PowNum = _OLED_Pow(10, FraLength);		//根据指定小数的位数，确定乘数
	FraNum = (uint32)(Number * PowNum + 0.5);		//将小数乘到整数，同时四舍五入，避免显示误差
	IntNum += FraNum / PowNum;				//若四舍五入造成了进位，则需要再加给整数
	
	/*显示整数部分*/
	OLED_ShowNum(X + FontSize, Y, IntNum, IntLength, FontSize);
	
	/*显示小数点*/
	OLED_ShowChar(X + (IntLength + 1) * FontSize, Y, '.', FontSize);
	
	/*显示小数部分*/
	OLED_ShowNum(X + (IntLength + 2) * FontSize, Y, FraNum, FraLength, FontSize);
}

/**
  * 函    数：OLED显示汉字串
  * 参    数：X 指定汉字串左上角的横坐标，范围：0~127
  * 参    数：Y 指定汉字串左上角的纵坐标，范围：0~63
  * 参    数：Chinese 指定要显示的汉字串，范围：必须全部为汉字或者全角字符，不要加入任何半角字符
  *           显示的汉字需要在OLED_Data.c里的OLED_CF16x16数组定义
  *           未找到指定汉字时，会显示默认图形（一个方框，内部一个问号）
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowChinese(uint8 X, uint8 Y, char *Chinese)
{
	uint8 pChinese = 0;
	uint8 pIndex;
	uint8 i;
	char SingleChinese[OLED_CHN_CHAR_WIDTH + 1] = {0};

	for (i = 0; Chinese[i] != '\0'; i ++)		//遍历汉字串
	{
		SingleChinese[pChinese] = Chinese[i];	//提取汉字串数据到单个汉字数组
		pChinese ++;							//计次自增

		/*当提取次数到达OLED_CHN_CHAR_WIDTH时，即代表提取到了一个完整的汉字*/
		if (pChinese >= OLED_CHN_CHAR_WIDTH)
		{
			pChinese = 0;		//计次归零

			/*遍历整个汉字字模库，寻找匹配的汉字*/
			/*如果找到最后一个汉字（定义为空字符串），则表示汉字未在字模库定义，停止寻找*/
			for (pIndex = 0; strcmp(OLED_CF16x16[pIndex].Index, "") != 0; pIndex ++)
			{
				/*找到匹配的汉字*/
				if (strcmp(OLED_CF16x16[pIndex].Index, SingleChinese) == 0)
				{
					break;		//跳出循环，此时pIndex的值为指定汉字的索引
				}
			}

			/*将汉字字模库OLED_CF16x16的指定数据以16*16的图像格式显示*/
			OLED_ShowImage(X + ((i + 1) / OLED_CHN_CHAR_WIDTH - 1) * 16, Y, 16, 16, OLED_CF16x16[pIndex].Data);
		}
	}
}

/**
  * 函    数：OLED显示图像
  * 参    数：X 指定图像左上角的横坐标，范围：0~127
  * 参    数：Y 指定图像左上角的纵坐标，范围：0~63
  * 参    数：Width 指定图像的宽度，范围：0~128
  * 参    数：Height 指定图像的高度，范围：0~64
  * 参    数：Image 指定要显示的图像
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_ShowImage(uint8 X, uint8 Y, uint8 Width, uint8 Height, const uint8 *Image)
{
	uint8 i, j;
	uint8 Height_ceil = (Height - 1) / 8 + 1;
	/*参数检查，保证指定图像不会超出屏幕范围*/
	if (X > 127) {return;}
	if (Y > 63) {return;}
	
	/*将图像所在区域清空*/
	OLED_ClearArea(X, Y, Width, Height);
	
	/*遍历指定图像涉及的相关页*/
	/*(Height - 1) / 8 + 1的目的是Height / 8并向上取整*/
	
	for (j = 0; j < Height_ceil; j ++)
	{
		/*遍历指定图像涉及的相关列*/
		for (i = 0; i < Width; i ++)
		{
			/*超出边界，则跳过显示*/
			if (X + i > 127) {break;}
			if (Y / 8 + j > 7) {return;}
			
			/*显示图像在当前页的内容*/
			OLED_DisplayBuf[Y / 8 + j][X + i] |= Image[j * Width + i] << (Y % 8);
			
			/*超出边界，则跳过显示*/
			/*使用continue的目的是，下一页超出边界时，上一页的后续内容还需要继续显示*/
			if (Y / 8 + j + 1 > 7) {continue;}
			
			/*显示图像在下一页的内容*/
			OLED_DisplayBuf[Y / 8 + j + 1][X + i] |= Image[j * Width + i] >> (8 - Y % 8);
		}
	}
}

/**
  * 函    数：OLED使用printf函数打印格式化字符串
  * 参    数：X 指定格式化字符串左上角的横坐标，范围：0~127
  * 参    数：Y 指定格式化字符串左上角的纵坐标，范围：0~63
  * 参    数：FontSize 指定字体大小
  *           范围：OLED_8X16		宽8像素，高16像素
  *                 OLED_6X8		宽6像素，高8像素
  * 参    数：format 指定要显示的格式化字符串，范围：ASCII码可见字符组成的字符串
  * 参    数：... 格式化字符串参数列表
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_Printf(uint8 X, uint8 Y, uint8 FontSize, char *format, ...)
{
	char String[30];						//定义字符数组
	va_list arg;							//定义可变参数列表数据类型的变量arg
	va_start(arg, format);					//从format开始，接收参数列表到arg变量
	vsprintf(String, format, arg);			//使用vsprintf打印格式化字符串和参数列表到字符数组中
	va_end(arg);							//结束变量arg
	OLED_ShowString(X, Y, String, FontSize);//OLED显示字符数组（字符串）
}

/**
  * 函    数：OLED在指定位置画一个点
  * 参    数：X 指定点的横坐标，范围：0~127
  * 参    数：Y 指定点的纵坐标，范围：0~63
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_DrawPoint(uint8 X, uint8 Y)
{
	/*参数检查，保证指定位置不会超出屏幕范围*/
	if (X > 127) {return;}
	if (Y > 63) {return;}
	
	/*将显存数组指定位置的一个Bit数据置1*/
	OLED_DisplayBuf[Y / 8][X] |= 0x01 << (Y % 8);
}

/**
  * 函    数：OLED获取指定位置点的值
  * 参    数：X 指定点的横坐标，范围：0~127
  * 参    数：Y 指定点的纵坐标，范围：0~63
  * 返 回 值：指定位置点是否处于点亮状态，1：点亮，0：熄灭
  */
uint8 OLED_GetPoint(uint8 X, uint8 Y)
{
	/*参数检查，保证指定位置不会超出屏幕范围*/
	if (X > 127) {return 0;}
	if (Y > 63) {return 0;}
	
	/*判断指定位置的数据*/
	if (OLED_DisplayBuf[Y / 8][X] & 0x01 << (Y % 8))
	{
		return 1;	//为1，返回1
	}
	
	return 0;		//否则，返回0
}

/**
  * 函    数：OLED画线
  * 参    数：X0 指定一个端点的横坐标，范围：0~127
  * 参    数：Y0 指定一个端点的纵坐标，范围：0~63
  * 参    数：X1 指定另一个端点的横坐标，范围：0~127
  * 参    数：Y1 指定另一个端点的纵坐标，范围：0~63
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_DrawLine(uint8 X0, uint8 Y0, uint8 X1, uint8 Y1)
{
    int x, y, temp;
    int dx, dy, d, incrE, incrNE;
	int x0 = X0, y0 = Y0, x1 = X1, y1 = Y1;
	uint8 yflag = 0, xyflag = 0;
	
	if (y0 == y1)		//横线单独处理
	{
		/*0号点X坐标大于1号点X坐标，则交换两点X坐标*/
		if (x0 > x1) {temp = x0; x0 = x1; x1 = temp;}
		
		/*遍历X坐标*/
		for (x = x0; x <= x1; x ++)
		{
			OLED_DrawPoint((uint8)x, (uint8)y0);	//依次画点
		}
	}
	else if (x0 == x1)	//竖线单独处理
	{
		/*0号点Y坐标大于1号点Y坐标，则交换两点Y坐标*/
		if (y0 > y1) {temp = y0; y0 = y1; y1 = temp;}
		
		/*遍历Y坐标*/
		for (y = y0; y <= y1; y ++)
		{
			OLED_DrawPoint((uint8)x0, (uint8)y);	//依次画点
		}
	}
	else				//斜线
	{
		/*使用Bresenham算法画直线，可以避免耗时的浮点运算，效率更高*/
		/*参考文档：https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/
		/*参考教程：https://www.bilibili.com/video/BV1364y1d7Lo*/
		
		if (x0 > x1)	//0号点X坐标大于1号点X坐标
		{
			/*交换两点坐标*/
			/*交换后不影响画线，但是画线方向由第一、二、三、四象限变为第一、四象限*/
			temp = x0; x0 = x1; x1 = temp;
			temp = y0; y0 = y1; y1 = temp;
		}
		
		if (y0 > y1)	//0号点Y坐标大于1号点Y坐标
		{
			/*将Y坐标取负*/
			/*取负后影响画线，但是画线方向由第一、四象限变为第一象限*/
			y0 = -1 * y0;
			y1 = -1 * y1;
			
			/*置标志位yflag，记住当前变换，在后续实际画线时，再将坐标换回来*/
			yflag = 1;
		}
		
		if (y1 - y0 > x1 - x0)	//画线斜率大于1
		{
			/*将X坐标与Y坐标互换*/
			/*互换后影响画线，但是画线方向由第一象限0~90度范围变为第一象限0~45度范围*/
			temp = x0; x0 = y0; y0 = temp;
			temp = x1; x1 = y1; y1 = temp;
			
			/*置标志位xyflag，记住当前变换，在后续实际画线时，再将坐标换回来*/
			xyflag = 1;
		}
		
		/*以下为Bresenham算法画直线*/
		/*算法要求，画线方向必须为第一象限0~45度范围*/
		dx = x1 - x0;
		dy = y1 - y0;
		incrE = 2 * dy;
		incrNE = 2 * (dy - dx);
		d = 2 * dy - dx;
		x = x0;
		y = y0;
		
		/*画起始点，同时判断标志位，将坐标换回来*/
		if (yflag && xyflag){OLED_DrawPoint((uint8)y, (uint8)(-x));}
		else if (yflag)		{OLED_DrawPoint((uint8)x, (uint8)(-y));}
		else if (xyflag)	{OLED_DrawPoint((uint8)y, (uint8)x);}
		else				{OLED_DrawPoint((uint8)x, (uint8)y);}
		
		while (x < x1)		//遍历X轴的每个点
		{
			x ++;
			if (d < 0)		//下一个点在当前点东方
			{
				d += incrE;
			}
			else			//下一个点在当前点东北方
			{
				y ++;
				d += incrNE;
			}
			
			/*画每一个点，同时判断标志位，将坐标换回来*/
			if (yflag && xyflag){OLED_DrawPoint((uint8)y, (uint8)(-x));}
			else if (yflag)		{OLED_DrawPoint((uint8)x, (uint8)(-y));}
			else if (xyflag)	{OLED_DrawPoint((uint8)y, (uint8)x);}
			else				{OLED_DrawPoint((uint8)x, (uint8)y);}
		}	
	}
}

/**
  * 函    数：OLED矩形
  * 参    数：X 指定矩形左上角的横坐标，范围：0~127
  * 参    数：Y 指定矩形左上角的纵坐标，范围：0~63
  * 参    数：Width 指定矩形的宽度，范围：0~128
  * 参    数：Height 指定矩形的高度，范围：0~64
  * 参    数：IsFilled 指定矩形是否填充
  *           范围：OLED_UNFILLED		不填充
  *                 OLED_FILLED			填充
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_DrawRectangle(uint8 X, uint8 Y, uint8 Width, uint8 Height, uint8 IsFilled)
{
	uint8 i, j;
	if (!IsFilled)		//指定矩形不填充
	{
		/*遍历上下X坐标，画矩形上下两条线*/
		for (i = X; i < X + Width; i ++)
		{
			OLED_DrawPoint(i, Y);
			OLED_DrawPoint(i, Y + Height - 1);
		}
		/*遍历左右Y坐标，画矩形左右两条线*/
		for (i = Y; i < Y + Height; i ++)
		{
			OLED_DrawPoint(X, i);
			OLED_DrawPoint(X + Width - 1, i);
		}
	}
	else				//指定矩形填充
	{
		/*遍历X坐标*/
		for (i = X; i < X + Width; i ++)
		{
			/*遍历Y坐标*/
			for (j = Y; j < Y + Height; j ++)
			{
				/*在指定区域画点，填充满矩形*/
				OLED_DrawPoint(i, j);
			}
		}
	}
}

/**
  * 函    数：OLED三角形
  * 参    数：X0 指定第一个端点的横坐标，范围：0~127
  * 参    数：Y0 指定第一个端点的纵坐标，范围：0~63
  * 参    数：X1 指定第二个端点的横坐标，范围：0~127
  * 参    数：Y1 指定第二个端点的纵坐标，范围：0~63
  * 参    数：X2 指定第三个端点的横坐标，范围：0~127
  * 参    数：Y2 指定第三个端点的纵坐标，范围：0~63
  * 参    数：IsFilled 指定三角形是否填充
  *           范围：OLED_UNFILLED		不填充
  *                 OLED_FILLED			填充
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_DrawTriangle(uint8 X0, uint8 Y0, uint8 X1, uint8 Y1, uint8 X2, uint8 Y2, uint8 IsFilled)
{
	uint8 minx = X0, miny = Y0, maxx = X0, maxy = Y0;
	uint8 i, j;
	uint16 vx[3];
	uint16 vy[3];
	vx[0] = X0; vx[1] = X1; vx[2] = X2;
	vy[0] = Y0; vy[1] = Y1; vy[2] = Y2;
	
	if (!IsFilled)			//指定三角形不填充
	{
		/*调用画线函数，将三个点用直线连接*/
		OLED_DrawLine(X0, Y0, X1, Y1);
		OLED_DrawLine(X0, Y0, X2, Y2);
		OLED_DrawLine(X1, Y1, X2, Y2);
	}
	else					//指定三角形填充
	{
		/*找到三个点最小的X、Y坐标*/
		if (X1 < minx) {minx = X1;}
		if (X2 < minx) {minx = X2;}
		if (Y1 < miny) {miny = Y1;}
		if (Y2 < miny) {miny = Y2;}
		
		/*找到三个点最大的X、Y坐标*/
		if (X1 > maxx) {maxx = X1;}
		if (X2 > maxx) {maxx = X2;}
		if (Y1 > maxy) {maxy = Y1;}
		if (Y2 > maxy) {maxy = Y2;}
		
		/*最小最大坐标之间的矩形为可能需要填充的区域*/
		/*遍历此区域中所有的点*/
		/*遍历X坐标*/		
		for (i = minx; i <= maxx; i ++)
		{
			/*遍历Y坐标*/	
			for (j = miny; j <= maxy; j ++)
			{
				/*调用OLED_pnpoly，判断指定点是否在指定三角形之中*/
				/*如果在，则画点，如果不在，则不做处理*/
				if (_OLED_pnpoly(3, vx, vy, i, j)) {OLED_DrawPoint(i, j);}
			}
		}
	}
}

/**
  * 函    数：OLED画圆
  * 参    数：X 指定圆的圆心横坐标，范围：0~127
  * 参    数：Y 指定圆的圆心纵坐标，范围：0~63
  * 参    数：Radius 指定圆的半径，范围：0~255
  * 参    数：IsFilled 指定圆是否填充
  *           范围：OLED_UNFILLED		不填充
  *                 OLED_FILLED			填充
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_DrawCircle(uint8 X, uint8 Y, uint8 Radius, uint8 IsFilled)
{
	int x, y, d, j;
	
	/*使用Bresenham算法画圆，可以避免耗时的浮点运算，效率更高*/
	/*参考文档：https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/
	/*参考教程：https://www.bilibili.com/video/BV1VM4y1u7wJ*/
	
	d = 1 - Radius;
	x = 0;
	y = Radius;
	
	/*画每个八分之一圆弧的起始点*/
	OLED_DrawPoint(X + x, Y + y);
	OLED_DrawPoint(X - x, Y - y);
	OLED_DrawPoint(X + y, Y + x);
	OLED_DrawPoint(X - y, Y - x);
	
	if (IsFilled)		//指定圆填充
	{
		/*遍历起始点Y坐标*/
		for (j = -y; j < y; j ++)
		{
			/*在指定区域画点，填充部分圆*/
			OLED_DrawPoint(X, Y + j);
		}
	}
	
	while (x < y)		//遍历X轴的每个点
	{
		x ++;
		if (d < 0)		//下一个点在当前点东方
		{
			d += 2 * x + 1;
		}
		else			//下一个点在当前点东南方
		{
			y --;
			d += 2 * (x - y) + 1;
		}
		
		/*画每个八分之一圆弧的点*/
		OLED_DrawPoint(X + x, Y + y);
		OLED_DrawPoint(X + y, Y + x);
		OLED_DrawPoint(X - x, Y - y);
		OLED_DrawPoint(X - y, Y - x);
		OLED_DrawPoint(X + x, Y - y);
		OLED_DrawPoint(X + y, Y - x);
		OLED_DrawPoint(X - x, Y + y);
		OLED_DrawPoint(X - y, Y + x);
		
		if (IsFilled)	//指定圆填充
		{
			/*遍历中间部分*/
			for (j = -y; j < y; j ++)
			{
				/*在指定区域画点，填充部分圆*/
				OLED_DrawPoint(X + x, Y + j);
				OLED_DrawPoint(X - x, Y + j);
			}
			
			/*遍历两侧部分*/
			for (j = -x; j < x; j ++)
			{
				/*在指定区域画点，填充部分圆*/
				OLED_DrawPoint(X - y, Y + j);
				OLED_DrawPoint(X + y, Y + j);
			}
		}
	}
}

/**
  * 函    数：OLED画椭圆
  * 参    数：X 指定椭圆的圆心横坐标，范围：0~127
  * 参    数：Y 指定椭圆的圆心纵坐标，范围：0~63
  * 参    数：A 指定椭圆的横向半轴长度，范围：0~255
  * 参    数：B 指定椭圆的纵向半轴长度，范围：0~255
  * 参    数：IsFilled 指定椭圆是否填充
  *           范围：OLED_UNFILLED		不填充
  *                 OLED_FILLED			填充
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_DrawEllipse(uint8 X, uint8 Y, uint8 A, uint8 B, uint8 IsFilled)
{
	uint16 x, y, j;
	uint16 a = A, b = B;
	float d1, d2;
	
	/*使用Bresenham算法画椭圆，可以避免部分耗时的浮点运算，效率更高*/
	/*参考链接：https://blog.csdn.net/myf_666/article/details/128167392*/
	
	x = 0;
	y = b;
	d1 = b * b + a * a * (-b + 0.5);
	
	if (IsFilled)	//指定椭圆填充
	{
		/*遍历起始点Y坐标*/
		for (j = -y; j < y; j ++)
		{
			/*在指定区域画点，填充部分椭圆*/
			OLED_DrawPoint(X, Y + j);
			OLED_DrawPoint(X, Y + j);
		}
	}
	
	/*画椭圆弧的起始点*/
	OLED_DrawPoint(X + x, Y + y);
	OLED_DrawPoint(X - x, Y - y);
	OLED_DrawPoint(X - x, Y + y);
	OLED_DrawPoint(X + x, Y - y);
	
	/*画椭圆中间部分*/
	while (b * b * (x + 1) < a * a * (y - 0.5))
	{
		if (d1 <= 0)		//下一个点在当前点东方
		{
			d1 += b * b * (2 * x + 3);
		}
		else				//下一个点在当前点东南方
		{
			d1 += b * b * (2 * x + 3) + a * a * (-2 * y + 2);
			y --;
		}
		x ++;
		
		if (IsFilled)	//指定椭圆填充
		{
			/*遍历中间部分*/
			for (j = -y; j < y; j ++)
			{
				/*在指定区域画点，填充部分椭圆*/
				OLED_DrawPoint(X + x, Y + j);
				OLED_DrawPoint(X - x, Y + j);
			}
		}
		
		/*画椭圆中间部分圆弧*/
		OLED_DrawPoint(X + x, Y + y);
		OLED_DrawPoint(X - x, Y - y);
		OLED_DrawPoint(X - x, Y + y);
		OLED_DrawPoint(X + x, Y - y);
	}
	
	/*画椭圆两侧部分*/
	d2 = b * b * (x + 0.5) * (x + 0.5) + a * a * (y - 1) * (y - 1) - a * a * b * b;
	
	while (y > 0)
	{
		if (d2 <= 0)		//下一个点在当前点东方
		{
			d2 += b * b * (2 * x + 2) + a * a * (-2 * y + 3);
			x ++;
			
		}
		else				//下一个点在当前点东南方
		{
			d2 += a * a * (-2 * y + 3);
		}
		y --;
		
		if (IsFilled)	//指定椭圆填充
		{
			/*遍历两侧部分*/
			for (j = -y; j < y; j ++)
			{
				/*在指定区域画点，填充部分椭圆*/
				OLED_DrawPoint(X + x, Y + j);
				OLED_DrawPoint(X - x, Y + j);
			}
		}
		
		/*画椭圆两侧部分圆弧*/
		OLED_DrawPoint(X + x, Y + y);
		OLED_DrawPoint(X - x, Y - y);
		OLED_DrawPoint(X - x, Y + y);
		OLED_DrawPoint(X + x, Y - y);
	}
}

/**
  * 函    数：OLED画圆弧
  * 参    数：X 指定圆弧的圆心横坐标，范围：0~127
  * 参    数：Y 指定圆弧的圆心纵坐标，范围：0~63
  * 参    数：Radius 指定圆弧的半径，范围：0~255
  * 参    数：StartAngle 指定圆弧的起始角度，范围：-180~180
  *           水平向右为0度，水平向左为180度或-180度，下方为正数，上方为负数，顺时针旋转
  * 参    数：EndAngle 指定圆弧的终止角度，范围：-180~180
  *           水平向右为0度，水平向左为180度或-180度，下方为正数，上方为负数，顺时针旋转
  * 参    数：IsFilled 指定圆弧是否填充，填充后为扇形
  *           范围：OLED_UNFILLED		不填充
  *                 OLED_FILLED			填充
  * 返 回 值：无
  * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
  */
void OLED_DrawArc(uint8 X, uint8 Y, uint8 Radius, uint16 StartAngle, uint16 EndAngle, uint8 IsFilled)
{
	uint16 x, y, d, j;
	
	/*此函数借用Bresenham算法画圆的方法*/
	
	d = 1 - Radius;
	x = 0;
	y = Radius;
	
	/*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
	if (_OLED_IsInAngle(x, y, StartAngle, EndAngle))	{OLED_DrawPoint(X + x, Y + y);}
	if (_OLED_IsInAngle(-x, -y, StartAngle, EndAngle)) {OLED_DrawPoint(X - x, Y - y);}
	if (_OLED_IsInAngle(y, x, StartAngle, EndAngle)) {OLED_DrawPoint(X + y, Y + x);}
	if (_OLED_IsInAngle(-y, -x, StartAngle, EndAngle)) {OLED_DrawPoint(X - y, Y - x);}
	
	if (IsFilled)	//指定圆弧填充
	{
		/*遍历起始点Y坐标*/
		for (j = -y; j < y; j ++)
		{
			/*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
			if (_OLED_IsInAngle(0, j, StartAngle, EndAngle)) {OLED_DrawPoint(X, Y + j);}
		}
	}
	
	while (x < y)		//遍历X轴的每个点
	{
		x ++;
		if (d < 0)		//下一个点在当前点东方
		{
			d += 2 * x + 1;
		}
		else			//下一个点在当前点东南方
		{
			y --;
			d += 2 * (x - y) + 1;
		}
		
		/*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
		if (_OLED_IsInAngle(x, y, StartAngle, EndAngle)) {OLED_DrawPoint(X + x, Y + y);}
		if (_OLED_IsInAngle(y, x, StartAngle, EndAngle)) {OLED_DrawPoint(X + y, Y + x);}
		if (_OLED_IsInAngle(-x, -y, StartAngle, EndAngle)) {OLED_DrawPoint(X - x, Y - y);}
		if (_OLED_IsInAngle(-y, -x, StartAngle, EndAngle)) {OLED_DrawPoint(X - y, Y - x);}
		if (_OLED_IsInAngle(x, -y, StartAngle, EndAngle)) {OLED_DrawPoint(X + x, Y - y);}
		if (_OLED_IsInAngle(y, -x, StartAngle, EndAngle)) {OLED_DrawPoint(X + y, Y - x);}
		if (_OLED_IsInAngle(-x, y, StartAngle, EndAngle)) {OLED_DrawPoint(X - x, Y + y);}
		if (_OLED_IsInAngle(-y, x, StartAngle, EndAngle)) {OLED_DrawPoint(X - y, Y + x);}
		
		if (IsFilled)	//指定圆弧填充
		{
			/*遍历中间部分*/
			for (j = -y; j < y; j ++)
			{
				/*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
				if (_OLED_IsInAngle(x, j, StartAngle, EndAngle)) {OLED_DrawPoint(X + x, Y + j);}
				if (_OLED_IsInAngle(-x, j, StartAngle, EndAngle)) {OLED_DrawPoint(X - x, Y + j);}
			}
			
			/*遍历两侧部分*/
			for (j = -x; j < x; j ++)
			{
				/*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*/
				if (_OLED_IsInAngle(-y, j, StartAngle, EndAngle)) {OLED_DrawPoint(X - y, Y + j);}
				if (_OLED_IsInAngle(y, j, StartAngle, EndAngle)) {OLED_DrawPoint(X + y, Y + j);}
			}
		}
	}
}

/*********************功能函数*/
